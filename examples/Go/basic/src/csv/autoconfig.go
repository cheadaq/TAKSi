// This file is auto-generated by TAKSi v1.3.0, DO NOT EDIT!
package config

import (
	"bytes"
	"encoding/csv"
	"io"
	"log"
	"strconv"
	"strings"
)

var (
	_ = io.EOF
	_ = strings.Split
	_ = log.Panicf
	_ = strconv.Atoi
	_ = bytes.NewReader
	_ = csv.NewReader
)

const (
	TAKSI_CSV_SEP     = `,`
	TAKSI_CSV_QUOTE   = `"`
	TAKSI_ARRAY_DELIM = `,`
	TAKSI_MAP_DELIM1  = `;`
	TAKSI_MAP_DELIM2  = `=`
)

const (
	KeySoldierPropertyDefineName = "soldier_property_define"
)

// 兵种属性配置, 兵种.xlsx
type SoldierPropertyDefine struct {
	Name               string  // 士兵ID
	Level              int     // 士兵等级
	NameID             string  // 名字
	Description        string  // 描述
	BuildingName       string  // 所属建筑
	BuildingLevel      uint32  // 建筑等级
	RequireSpace       uint32  // 登陆艇占用空间
	Volume             uint32  // 体积
	UpgradeTime        uint32  // 升级消耗的时间(秒）
	UpgradeMaterialID  string  // 升级消耗的材料
	UpgradeMaterialNum int64   // 升级消耗的数量
	ConsumeMaterial    string  // 生产消耗的材料
	ConsumeMaterialNum int     // 生产消耗的数量
	ConsumeTime        int     // 生产消耗的时间（秒/个）
	Act                int     // 攻击
	Hp                 int     // 血量
	Hurt               uint32  // buff伤害
	SearchScope        int16   // 搜索范围
	AtkFrequency       float32 // 攻击间隔
	AtkRange           float64 // 攻击距离
	MovingSpeed        float64 // 移动速度
	EnableBurn         bool    // 燃烧特效
}

func (p *SoldierPropertyDefine) ParseFromRow(row []string) error {
	if len(row) < 25 {
		log.Panicf("SoldierPropertyDefine: row length too short %d", len(row))
	}
	if row[0] != "" {
		p.Name = row[0]
	}
	if row[1] != "" {
		var value = MustParseTextValue("int", row[1], row)
		p.Level = value.(int)
	}
	if row[2] != "" {
		p.NameID = row[2]
	}
	if row[3] != "" {
		p.Description = row[3]
	}
	if row[4] != "" {
		p.BuildingName = row[4]
	}
	if row[5] != "" {
		var value = MustParseTextValue("uint32", row[5], row)
		p.BuildingLevel = value.(uint32)
	}
	if row[6] != "" {
		var value = MustParseTextValue("uint32", row[6], row)
		p.RequireSpace = value.(uint32)
	}
	if row[7] != "" {
		var value = MustParseTextValue("uint32", row[7], row)
		p.Volume = value.(uint32)
	}
	if row[8] != "" {
		var value = MustParseTextValue("uint32", row[8], row)
		p.UpgradeTime = value.(uint32)
	}
	if row[9] != "" {
		p.UpgradeMaterialID = row[9]
	}
	if row[10] != "" {
		var value = MustParseTextValue("int64", row[10], row)
		p.UpgradeMaterialNum = value.(int64)
	}
	if row[11] != "" {
		p.ConsumeMaterial = row[11]
	}
	if row[12] != "" {
		var value = MustParseTextValue("int", row[12], row)
		p.ConsumeMaterialNum = value.(int)
	}
	if row[13] != "" {
		var value = MustParseTextValue("int", row[13], row)
		p.ConsumeTime = value.(int)
	}
	if row[14] != "" {
		var value = MustParseTextValue("int", row[14], row)
		p.Act = value.(int)
	}
	if row[15] != "" {
		var value = MustParseTextValue("int", row[15], row)
		p.Hp = value.(int)
	}
	if row[17] != "" {
		var value = MustParseTextValue("uint32", row[17], row)
		p.Hurt = value.(uint32)
	}
	if row[20] != "" {
		var value = MustParseTextValue("int16", row[20], row)
		p.SearchScope = value.(int16)
	}
	if row[21] != "" {
		var value = MustParseTextValue("float32", row[21], row)
		p.AtkFrequency = value.(float32)
	}
	if row[22] != "" {
		var value = MustParseTextValue("float64", row[22], row)
		p.AtkRange = value.(float64)
	}
	if row[23] != "" {
		var value = MustParseTextValue("float64", row[23], row)
		p.MovingSpeed = value.(float64)
	}
	if row[24] != "" {
		var value = MustParseTextValue("bool", row[24], row)
		p.EnableBurn = value.(bool)
	}
	return nil
}

func LoadSoldierPropertyDefineList(data []byte) ([]*SoldierPropertyDefine, error) {
	var list []*SoldierPropertyDefine
	var r = csv.NewReader(bytes.NewReader(data))
	for i := 0; ; i++ {
		row, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Printf("SoldierPropertyDefine: read csv %v", err)
			return nil, err
		}
		var item SoldierPropertyDefine
		if err := item.ParseFromRow(row); err != nil {
			log.Printf("SoldierPropertyDefine: parse row %d, %s, %v", i+1, row, err)
			return nil, err
		}
		list = append(list, &item)
	}
	return list, nil
}

// parse bool value from text
func parseBool(text string) bool {
	switch len(text) {
	case 0:
		return false
	case 1:
		return text[0] == '1' || text[0] == 'Y' || text[0] == 'y'
	case 2:
		var value = strings.ToLower(text)
		return value == "on"
	case 3:
		var value = strings.ToLower(text)
		return value == "yes"
	case 4:
		var value = strings.ToLower(text)
		return value == "true"
	default:
		b, err := strconv.ParseBool(text)
		if err != nil {
			log.Panicf("%v, %v", text, err)
		}
		return b
	}
}

// MustParseTextValue parse text to value of type
func MustParseTextValue(typename, valueText string, msgtips interface{}) interface{} {
	switch typename {
	case "bool":
		return parseBool(valueText)

	case "float32", "float64":
		f, err := strconv.ParseFloat(valueText, 64)
		if err != nil {
			log.Panicf("%s %s, %v, %v", typename, valueText, err, msgtips)
		}
		if typename == "float32" {
			return float32(f)
		}
		return f // float64

	case "uint", "uint8", "uint16", "uint32", "uint64":
		n, err := strconv.ParseUint(valueText, 10, 64)
		if err != nil {
			log.Panicf("%s %s, %v, %v", typename, valueText, err, msgtips)
		}
		if typename == "uint" {
			return uint(n)
		} else if typename == "uint8" {
			return uint8(n)
		} else if typename == "uint16" {
			return uint16(n)
		} else if typename == "uint32" {
			return uint32(n)
		}
		return n // uint64

	case "int", "int8", "int16", "int32", "int64":
		n, err := strconv.ParseInt(valueText, 10, 64)
		if err != nil {
			log.Panicf("%s %s, %v, %v", typename, valueText, err, msgtips)
		}
		if typename == "int" {
			return int(n)
		} else if typename == "int8" {
			return int8(n)
		} else if typename == "int16" {
			return int16(n)
		} else if typename == "int32" {
			return int32(n)
		}
		return n // int64

	default:
		return valueText
	}
}
