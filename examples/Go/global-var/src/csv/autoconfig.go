// This file is auto-generated by TAKSi v1.3.0, DO NOT EDIT!
package config

import (
	"bytes"
	"encoding/csv"
	"io"
	"log"
	"strconv"
	"strings"
)

var (
	_ = io.EOF
	_ = strings.Split
	_ = log.Panicf
	_ = strconv.Atoi
	_ = bytes.NewReader
	_ = csv.NewReader
)

const (
	TAKSI_CSV_SEP     = `,`
	TAKSI_CSV_QUOTE   = `"`
	TAKSI_ARRAY_DELIM = `,`
	TAKSI_MAP_DELIM1  = `;`
	TAKSI_MAP_DELIM2  = `=`
)

const (
	KeyGlobalPropertyDefineName = "global_property_define"
)

// 全局数值配置, 全局变量表.xlsx
type GlobalPropertyDefine struct {
	GoldExchangeTimeFactor1    float32        // 金币兑换时间参数1
	GoldExchangeTimeFactor2    float32        // 金币兑换时间参数2
	GoldExchangeTimeFactor3    float32        // 金币兑换时间参数3
	GoldExchangeResource1Price uint32         // 金币兑换资源1价格
	GoldExchangeResource2Price uint32         // 金币兑换资源2价格
	GoldExchangeResource3Price uint32         // 金币兑换资源3价格
	GoldExchangeResource4Price uint32         // 金币兑换资源4价格
	FreeCompleteSeconds        uint32         // 免费立即完成时间
	CancelBuildReturnPercent   uint32         // 取消建造后返还资源比例
	SpawnLevelLimit            []int          // 最大刷新个数显示
	FirstRechargeReward        map[string]int // 首充奖励
}

func (p *GlobalPropertyDefine) ParseFromRows(rows [][]string) error {
	if len(rows) < 11 {
		log.Panicf("GlobalPropertyDefine:row length out of index, %d < 11", len(rows))
	}
	if rows[0][3] != "" {
		var value = MustParseTextValue("float32", rows[0][3], 0)
		p.GoldExchangeTimeFactor1 = value.(float32)
	}
	if rows[1][3] != "" {
		var value = MustParseTextValue("float32", rows[1][3], 1)
		p.GoldExchangeTimeFactor2 = value.(float32)
	}
	if rows[2][3] != "" {
		var value = MustParseTextValue("float32", rows[2][3], 2)
		p.GoldExchangeTimeFactor3 = value.(float32)
	}
	if rows[3][3] != "" {
		var value = MustParseTextValue("uint32", rows[3][3], 3)
		p.GoldExchangeResource1Price = value.(uint32)
	}
	if rows[4][3] != "" {
		var value = MustParseTextValue("uint32", rows[4][3], 4)
		p.GoldExchangeResource2Price = value.(uint32)
	}
	if rows[5][3] != "" {
		var value = MustParseTextValue("uint32", rows[5][3], 5)
		p.GoldExchangeResource3Price = value.(uint32)
	}
	if rows[6][3] != "" {
		var value = MustParseTextValue("uint32", rows[6][3], 6)
		p.GoldExchangeResource4Price = value.(uint32)
	}
	if rows[7][3] != "" {
		var value = MustParseTextValue("uint32", rows[7][3], 7)
		p.FreeCompleteSeconds = value.(uint32)
	}
	if rows[8][3] != "" {
		var value = MustParseTextValue("uint32", rows[8][3], 8)
		p.CancelBuildReturnPercent = value.(uint32)
	}
	if rows[9][3] != "" {
		for _, item := range strings.Split(rows[9][3], TAKSI_ARRAY_DELIM) {
			var value = MustParseTextValue("int", item, rows[9][3])
			p.SpawnLevelLimit = append(p.SpawnLevelLimit, value.(int))
		}
	}
	if rows[10][3] != "" {
		p.FirstRechargeReward = map[string]int{}
		for _, text := range strings.Split(rows[10][3], TAKSI_MAP_DELIM1) {
			if text == "" {
				continue
			}
			var items = strings.Split(text, TAKSI_MAP_DELIM2)
			var value = MustParseTextValue("string", items[0], rows[10][3])
			var key = value.(string)
			value = MustParseTextValue("int", items[1], rows[10][3])
			var val = value.(int)
			p.FirstRechargeReward[key] = val
		}
	}
	return nil
}

func LoadGlobalPropertyDefine(data []byte) (*GlobalPropertyDefine, error) {
	r := csv.NewReader(bytes.NewReader(data))
	rows, err := r.ReadAll()
	if err != nil {
		log.Printf("GlobalPropertyDefine: csv read all, %v", err)
		return nil, err
	}
	var item GlobalPropertyDefine
	if err := item.ParseFromRows(rows); err != nil {
		log.Printf("GlobalPropertyDefine: parse row %d, %v", len(rows), err)
		return nil, err
	}
	return &item, nil
}

// parse bool value from text
func parseBool(text string) bool {
	switch len(text) {
	case 0:
		return false
	case 1:
		return text[0] == '1' || text[0] == 'Y' || text[0] == 'y'
	case 2:
		var value = strings.ToLower(text)
		return value == "on"
	case 3:
		var value = strings.ToLower(text)
		return value == "yes"
	case 4:
		var value = strings.ToLower(text)
		return value == "true"
	default:
		b, err := strconv.ParseBool(text)
		if err != nil {
			log.Panicf("%v, %v", text, err)
		}
		return b
	}
}

// MustParseTextValue parse text to value of type
func MustParseTextValue(typename, valueText string, msgtips interface{}) interface{} {
	switch typename {
	case "bool":
		return parseBool(valueText)

	case "float32", "float64":
		f, err := strconv.ParseFloat(valueText, 64)
		if err != nil {
			log.Panicf("%s %s, %v, %v", typename, valueText, err, msgtips)
		}
		if typename == "float32" {
			return float32(f)
		}
		return f // float64

	case "uint", "uint8", "uint16", "uint32", "uint64":
		n, err := strconv.ParseUint(valueText, 10, 64)
		if err != nil {
			log.Panicf("%s %s, %v, %v", typename, valueText, err, msgtips)
		}
		if typename == "uint" {
			return uint(n)
		} else if typename == "uint8" {
			return uint8(n)
		} else if typename == "uint16" {
			return uint16(n)
		} else if typename == "uint32" {
			return uint32(n)
		}
		return n // uint64

	case "int", "int8", "int16", "int32", "int64":
		n, err := strconv.ParseInt(valueText, 10, 64)
		if err != nil {
			log.Panicf("%s %s, %v, %v", typename, valueText, err, msgtips)
		}
		if typename == "int" {
			return int(n)
		} else if typename == "int8" {
			return int8(n)
		} else if typename == "int16" {
			return int16(n)
		} else if typename == "int32" {
			return int32(n)
		}
		return n // int64

	default:
		return valueText
	}
}
