// This file is auto-generated by Tabular v0.9.1, DO NOT EDIT!

#include "GlobalDefine.h"
#include <stddef.h>
#include <assert.h>
#include <memory>
#include <fstream>
#include "Conv.h"
#include "StringUtil.h"

using namespace std;

#ifndef ASSERT
#define ASSERT assert
#endif


namespace config {

// parse GlobalPropertyDefine from string fields
int GlobalPropertyDefine::ParseFrom(const std::unordered_map<std::string, std::string>& fields, GlobalPropertyDefine* ptr)
{
    ASSERT(ptr != nullptr);
    std::unordered_map<std::string, std::string>::const_iterator iter;
    iter = fields.find("GoldExchangeTimeFactor1");
    if (iter != fields.end()) {
        ptr->GoldExchangeTimeFactor1 = ParseDouble(iter->second);
    }
    iter = fields.find("GoldExchangeTimeFactor2");
    if (iter != fields.end()) {
        ptr->GoldExchangeTimeFactor2 = ParseDouble(iter->second);
    }
    iter = fields.find("GoldExchangeTimeFactor3");
    if (iter != fields.end()) {
        ptr->GoldExchangeTimeFactor3 = ParseDouble(iter->second);
    }
    iter = fields.find("GoldExchangeResource1Price");
    if (iter != fields.end()) {
        ptr->GoldExchangeResource1Price = ParseUInt16(iter->second);
    }
    iter = fields.find("GoldExchangeResource2Price");
    if (iter != fields.end()) {
        ptr->GoldExchangeResource2Price = ParseUInt16(iter->second);
    }
    iter = fields.find("GoldExchangeResource3Price");
    if (iter != fields.end()) {
        ptr->GoldExchangeResource3Price = ParseUInt16(iter->second);
    }
    iter = fields.find("GoldExchangeResource4Price");
    if (iter != fields.end()) {
        ptr->GoldExchangeResource4Price = ParseUInt16(iter->second);
    }
    iter = fields.find("FreeCompleteSeconds");
    if (iter != fields.end()) {
        ptr->FreeCompleteSeconds = ParseUInt16(iter->second);
    }
    iter = fields.find("CancelBuildReturnPercent");
    if (iter != fields.end()) {
        ptr->CancelBuildReturnPercent = ParseUInt16(iter->second);
    }
    iter = fields.find("EnableSearch");
    if (iter != fields.end()) {
        ptr->EnableSearch = ParseBool(iter->second);
    }
    iter = fields.find("SpawnLevelLimit");
    if (iter != fields.end()) {
        auto arr = SplitString(iter->second, "|");
        for (size_t i = 0; i < arr.size(); i++)
        {
            auto val = ParseInt32(arr[i]);
            ptr->SpawnLevelLimit.emplace_back(val);
        }
    }
    iter = fields.find("FirstRechargeReward");
    if (iter != fields.end()) {
        auto kvs = SplitString(iter->second, "|");
        for (size_t i = 0; i < kvs.size(); i++)
        {
            auto kv = SplitString(kvs[i], "=");
            ASSERT(kv.size() == 2);
            if(kv.size() == 2)
            {
                auto key = StripWhitespace(kv[0]);
                auto val = ParseInt32(kv[1]);
                ASSERT(ptr->FirstRechargeReward.count(key) == 0);
                ptr->FirstRechargeReward.emplace(std::make_pair(key, val));
            }
        }
    }
    iter = fields.find("VIPItemReward");
    if (iter != fields.end()) {
        auto kvs = SplitString(iter->second, "|");
        for (size_t i = 0; i < kvs.size(); i++)
        {
            auto kv = SplitString(kvs[i], "=");
            ASSERT(kv.size() == 2);
            if(kv.size() == 2)
            {
                auto key = ParseInt32(kv[0]);
                auto val = ParseInt32(kv[1]);
                ASSERT(ptr->VIPItemReward.count(key) == 0);
                ptr->VIPItemReward.emplace(std::make_pair(key, val));
            }
        }
    }
    return 0;
}


} // namespace config 
