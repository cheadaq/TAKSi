// This file is auto-generated by Tabular v0.9.1, DO NOT EDIT!

#include "GlobalDefine.h"
#include <stddef.h>
#include <assert.h>
#include <memory>
#include <fstream>
#include "Conv.h"
#include "StringUtil.h"

using namespace std;

#ifndef ASSERT
#define ASSERT assert
#endif


namespace config {

// parse data object from record
int GlobalPropertyDefine::ParseFrom(std::unordered_map<std::string, std::string>& fields, GlobalPropertyDefine* ptr)
{
    ASSERT(ptr != nullptr);
    ptr->GoldExchangeTimeFactor1 = to<double>(fields["GoldExchangeTimeFactor1"]);
    ptr->GoldExchangeTimeFactor2 = to<double>(fields["GoldExchangeTimeFactor2"]);
    ptr->GoldExchangeTimeFactor3 = to<double>(fields["GoldExchangeTimeFactor3"]);
    ptr->GoldExchangeResource1Price = to<uint16_t>(fields["GoldExchangeResource1Price"]);
    ptr->GoldExchangeResource2Price = to<uint16_t>(fields["GoldExchangeResource2Price"]);
    ptr->GoldExchangeResource3Price = to<uint16_t>(fields["GoldExchangeResource3Price"]);
    ptr->GoldExchangeResource4Price = to<uint16_t>(fields["GoldExchangeResource4Price"]);
    ptr->FreeCompleteSeconds = to<uint16_t>(fields["FreeCompleteSeconds"]);
    ptr->CancelBuildReturnPercent = to<uint16_t>(fields["CancelBuildReturnPercent"]);
    ptr->EnableSearch = to<bool>(fields["EnableSearch"]);
    {
        const auto& arr = SplitString(fields["SpawnLevelLimit"], "|");
        for (size_t i = 0; i < arr.size(); i++)
        {
            if (!arr[i].empty()) {
                const auto& val = to<int>(arr[i]);
                ptr->SpawnLevelLimit.emplace_back(val);
            }
        }
    }
    {
        const auto& kvs = SplitString(fields["FirstRechargeReward"], "|");
        for (size_t i = 0; i < kvs.size(); i++)
        {
            const auto& kv = SplitString(kvs[i], "=");
            ASSERT(kv.size() == 2);
            if(kv.size() == 2)
            {
                const auto& key = to<std::string>(kv[0]);
                const auto& val = to<int>(kv[1]);
                ASSERT(ptr->FirstRechargeReward.count(key) == 0);
                ptr->FirstRechargeReward.emplace(std::make_pair(key, val));
            }
        }
    }
    {
        const auto& kvs = SplitString(fields["VIPItemReward"], "|");
        for (size_t i = 0; i < kvs.size(); i++)
        {
            const auto& kv = SplitString(kvs[i], "=");
            ASSERT(kv.size() == 2);
            if(kv.size() == 2)
            {
                const auto& key = to<int>(kv[0]);
                const auto& val = to<int>(kv[1]);
                ASSERT(ptr->VIPItemReward.count(key) == 0);
                ptr->VIPItemReward.emplace(std::make_pair(key, val));
            }
        }
    }
    return 0;
}


} // namespace config 
