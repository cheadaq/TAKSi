// This file is auto-generated by Tabular v0.6.1, DO NOT EDIT!

#include "AutogenConfig.h"
#include <stddef.h>
#include <assert.h>
#include <memory>
#include <fstream>
#include "Utility/Conv.h"
#include "Utility/StringUtil.h"

using namespace std;

#ifndef ASSERT
#define ASSERT assert
#endif


namespace config {

// parse data object from csv rows
int GlobalPropertyDefine::ParseFromRows(const vector<vector<StringPiece>>& rows, GlobalPropertyDefine* ptr)
{
    ASSERT(rows.size() >= 12 && rows[0].size() >= 2);
    ASSERT(ptr != nullptr);
    ptr->GoldExchangeTimeFactor1 = parseTextAs<double>(rows[0][2]);
    ptr->GoldExchangeTimeFactor2 = parseTextAs<double>(rows[1][2]);
    ptr->GoldExchangeTimeFactor3 = parseTextAs<double>(rows[2][2]);
    ptr->GoldExchangeResource1Price = parseTextAs<uint16_t>(rows[3][2]);
    ptr->GoldExchangeResource2Price = parseTextAs<uint16_t>(rows[4][2]);
    ptr->GoldExchangeResource3Price = parseTextAs<uint16_t>(rows[5][2]);
    ptr->GoldExchangeResource4Price = parseTextAs<uint16_t>(rows[6][2]);
    ptr->FreeCompleteSeconds = parseTextAs<uint16_t>(rows[7][2]);
    ptr->CancelBuildReturnPercent = parseTextAs<uint16_t>(rows[8][2]);
    ptr->EnableSearch = parseTextAs<bool>(rows[9][2]);
    {
        const auto& array = Split(rows[10][2], TABULAR_ARRAY_DELIM, true);
        for (size_t i = 0; i < array.size(); i++)
        {
            ptr->SpawnLevelLimit.push_back(parseTextAs<int>(array[i]));
        }
    }
    {
        const auto& dict = Split(rows[11][2], TABULAR_MAP_DELIM1, true);
        for (size_t i = 0; i < dict.size(); i++)
        {
            const auto& kv = Split(dict[i], TABULAR_MAP_DELIM2, true);
            ASSERT(kv.size() == 2);
            if(kv.size() == 2)
            {
                const auto& key = parseTextAs<std::string>(kv[0]);
                ASSERT(ptr->FirstRechargeReward.count(key) == 0);
                ptr->FirstRechargeReward[key] = parseTextAs<int>(kv[1]);
            }
        }
    }
    return 0;
}


} // namespace config 
